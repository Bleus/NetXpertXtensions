using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using NetXpertExtensions;

namespace NetXpertCodeLibrary.ConfigManagement
{
    /// <summary>A static class allowing singleton AES de/encryption routines to be applied without requiring instantiation.</summary>
    public static class AES
    {
        private static byte[] MATRIX = new byte[] {
            0x2b, 0x4a, 0x6a, 0x38, 0x37, 0x33, 0x57, 0x69, 0x48, 0x68, 0x4c, 0x6c, 0x5a, 0x7a, 0x4d, 0x51,
            0x77, 0x34, 0x35, 0x56, 0x76, 0x36, 0x32, 0x39, 0x6e, 0x31, 0x50, 0x70, 0x41, 0x61, 0x43, 0x68,
            0x63, 0x4f, 0x6f, 0x45, 0x65, 0x46, 0x66, 0x47, 0x67, 0x49, 0x71, 0x52, 0x72, 0x53, 0x73, 0x48,
            0x54, 0x74, 0x55, 0x75, 0x44, 0x64, 0x58, 0x78, 0x59, 0x79, 0x30, 0x6d, 0x42, 0x62, 0x4e, 0x24,
        };

        public static Encoding DefaultEncoding { get; set; } = Encoding.UTF8;

        private static string Map 
        { 
            get => DefaultEncoding.GetString( MATRIX ); 
            set
			{
                if ( ( value is not null) && ( value.Length == 64 ) )
                {
                    byte[] Value = DefaultEncoding.GetBytes( value );
                    if ( (Value.Length == 64) && (new HashSet<byte>( Value ).Count == 64) )
                        MATRIX = Value;
                }
			}
        }

        public static AESWorker Cipher { get; set; } = new AESWorker();

        /// <summary>Encrypts a byte array to a byte array.</summary>
        public static byte[] Encrypt( byte[] data ) =>
            Cipher.Encrypt( data );

        /// <summary>Decrypts a byte array to a byte array.</summary>
        public static byte[] Decrypt( byte[] data ) =>
            Cipher.Decrypt( data );

        /// <summary>Encrypts a byte array to a plaintext string.</summary>
        public static string EncryptToString( byte[] source ) => Convert( Encrypt( source ) );

        /// <summary>Decrypts a string produced by "EncryptStringToString" to a byte array.</summary>
        public static byte[] DecryptString( string source ) => Decrypt( Convert( source ) );

        /// <summary>Encrypts a plaintext string to a plaintext string.</summary>
        public static string EncryptStringToString( string source, Encoding encoding = null ) =>
            Convert( Encrypt( ((encoding is null) ? DefaultEncoding : encoding).GetBytes( source ) ) );

        /// <summary>Decrypts a string created by "EncryptStringToString" back to the original text.</summary>
        public static string DecryptStringToString( string source, Encoding encoding = null ) =>
            ((encoding is null) ? DefaultEncoding : encoding).GetString( DecryptString( source ) );

        /// <summary>Parses an array of bytes (binary data) into an encoded plaintext string.</summary>
        private static string Convert( byte[] source )
		{
            List<byte> work = new List<byte>( source ), output = new List<byte>();
            while ( work.Count % 6 > 0 ) work.Add( 0 ); // Pad source data to land on a 6-byte boundary.

            for ( int i = 0; i < work.Count; )
            {
                ulong sixBytes = 0; //, test = 0;
                for ( int j = 0; j < 8; j++ ) // Parse 6 bytes of binary data into 8 bytes of string data...
                {
                    if ( j < 6 ) sixBytes += (ulong)work[ i++ ] << (j * 8);
                    output.Add( (byte)((sixBytes & (0x3ful << (6 * j))) >> (6 * j)) );
                }
            }

            string result = ""; // Encoding.ASCII.GetString( output.ToArray() );
            foreach ( byte b in output ) result += MATRIX[ b ];
            return Regex.Replace( result, $"[{Map[ 0 ]}]+$", "" ); // Remove surplus trailing zeros
        }

        /// <summary>Parses a plaintext string (generated by this class!) back into an array of bytes (binary data).</summary>
        private static byte[] Convert( string source )
		{
            List<byte> result = new();
            if ( !string.IsNullOrWhiteSpace( source ) )
            {
                if ( source.Length % 8 > 0 )
                    source.PadRight( (int)Math.Ceiling( (decimal)source.Length / 8M ) * 8, '+' );

                for ( int i = 0; i < source.Length / 8; i++ )
                {
                    byte[] block = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };
                    ulong sixBytes = 0;
                    for ( int j = 0; j < 8; j++ )
                    {
                        ulong value = (ulong)Map.IndexOf( source[ (i * 8) + j ] );
                        sixBytes += value << (6 * j);
                    }

                    block.Fill<byte>( 0, 8, false );
                    for ( int j = 0; j < 6; j++ )
                        result.Add( (byte)((sixBytes & (0xffUL << (j * 8))) >> (j * 8)) );
                }
            }

            while ( result.Count % 8 > 0 ) result.Add( 0 );

            return result.ToArray();
        }
    }

    /// <summary>Facilitates basic AES en/decryption using specified key values.</summary>
    public sealed class AESWorker
    {
		#region Properties
		// key source: "BullseyeSportsLondonIncorporated"
		private static byte[] _key = { 
            /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                 66, 117, 108, 108, 115, 101, 121, 101,  83, 112, 111, 114, 116, 115,  76, 111, 
                110, 100, 111, 110,  73, 110,  99, 111, 114, 112, 111, 114,  97, 116, 101, 100 
            
                  0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F */
                0x42, 0x75, 0x6c, 0x6c, 0x73, 0x65, 0x79, 0x65, 0x53, 0x70, 0x69, 0x72, 0x74, 0x73, 0x4c, 0x6f,
				0x6e, 0x64, 0x6f, 0x6e, 0x49, 0x6e, 0x63, 0x6f, 0x72, 0x70, 0x69, 0x72, 0x61, 0x74, 0x65, 0x64,
			};

        // vector source: "ScottPatience678"
        private static byte[] _vector = { 
            /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
                83,  99, 111, 116, 116,  80,  97, 116, 105, 101, 110,  99, 101,  54,  55,  56 
            
                  0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F */
                0x53, 0x63, 0x6f, 0x74, 0x74, 0x50, 0x61, 0x74, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x36, 0x37, 0x38
        };

        private AESKey _encrKey = new AESKey( _key, _vector );
        #endregion

        #region Constructors
        public AESWorker() { } // Uses default keys.

        public AESWorker( byte[] key, byte[] vector ) =>
            this.Key = new AESKey( key, vector );

        public AESWorker( string key ) =>
            this.Key = AESKey.Parse( key );

        public AESWorker( AESKey key ) =>
            this.Key = key;
        #endregion

        #region Accessors
        public AESKey Key
        {
            get => _encrKey;
            set => _encrKey = (value is null) ? _encrKey : value;
        }
		#endregion

		#region Methods
		/// <summary>Encrypts a plaintext string using AES.</summary>
		/// <param name="data">The string to be encrypted.</param>
		/// <returns>A string containing the AES encrypted version of the original as a hexadecimal value.</returns>
		/// <remarks>Uses the values stored in AES.Key and AES.Vector, make sure you define them before using this!</remarks>
		public string Encrypt( string data ) =>
            string.IsNullOrEmpty( data ) ? "" : SimpleAES.ByteArrToHexString( SimpleAES.EncryptString( data, _encrKey.Key, _encrKey.Vector ) );

        /// <summary>Encrypts a binary data set (contained in a byte array) using AES.</summary>
        /// <param name="data">The string to be encrypted.</param>
        /// <returns>An array of bytes containing the AES encrypted version of the original as a hexadecimal value.</returns>
        /// <remarks>Uses the values stored in AES.Key and AES.Vector, make sure you define them before using this!</remarks>
        public byte[] Encrypt( byte[] data ) =>
            data.Length == 0 ? data : SimpleAES.Encrypt( data, _encrKey.Key, _encrKey.Vector );

        /// <summary>Decrypts a binary data set (contained in a byte array) using AES.</summary>
        /// <param name="data">The string to be decrypted.</param>
        /// <returns>An array of bytes containing the decrypted data.</returns>
        /// <remarks>Uses the values stored in AES.Key and AES.Vector, make sure you define them before using this!</remarks>
        public byte[] Decrypt( byte[] data ) =>
            data.Length == 0 ? data : SimpleAES.Decrypt( data, _encrKey.Key, _encrKey.Vector );

        /// <summary>Decrypts a hexadecimal string.</summary>
        /// <param name="data">The string containing the hexadecimal value to decrypt.</param>
        /// <returns>A string containing the plaintext decrypted value.</returns>
        /// <remarks>Uses the values stored in AES.Key and AES.Vector, make sure you define them before using this!</remarks>
        public string Decrypt( string data ) =>
            string.IsNullOrEmpty( data ) ? "" : Encoding.ASCII.GetString( SimpleAES.DecryptHexString( data, _encrKey.Key, _encrKey.Vector ) );
        #endregion
    }


    #region SimpleAES Class by Mark Brittingham
    /// <summary>Implements a simple AES En/Decryption algorithm.</summary>
    /// <remarks>The foundation for this code was lifted from StackOverflow, with thanks to Mark Brittingham (link below)</remarks>
    /// <seealso cref="http://stackoverflow.com/questions/165808/simple-two-way-encryption-for-c-sharp"/>
    internal class SimpleAES
    {
        #region Properties
        // Change these! (key = 32 bytes; vector = 16 bytes):
        //private byte[] _key = { 37, 112, 222, 53, 196, 184, 27, 162, 29, 24, 26, 17, 218, 131, 209, 241, 24, 175, 144, 173, 236, 53, 123, 217, 19, 11, 24, 26, 85, 45, 114, 209 };
        //private byte[] _vector = { 146, 113, 79, 32, 114, 112, 64, 191, 111, 23, 3, 119, 231, 121, 252, 111 };
        public static readonly AESKey DEFAULT_ENC_KEY = "{T+Uw3ifyNobOmuHabIm7JSJXiWev3xMWLx+cblZFjCG§hcwLqoOn+2vNMf1HUUO$0P}";

        private AESKey _defaultEncrKey = DEFAULT_ENC_KEY;

        private ICryptoTransform _encryptorTransform, _decryptorTransform;
        #endregion

        #region Constructors
        public SimpleAES( string key, string vector )
        {
            if ( (key.Length > 31) && (vector.Length > 15) )
                this._defaultEncrKey = new AESKey( Encoding.ASCII.GetBytes( key.Substring( 0, 32 ) ), Encoding.ASCII.GetBytes( vector.Substring( 0, 16 ) ) );

            this.Init();
        }

        public SimpleAES( byte[] key, byte[] vector )
        {
            if ( (key.Length > 31) && (vector.Length > 15) )
                this._defaultEncrKey = new AESKey( key, vector );

            this.Init();
        }

        public SimpleAES( AESKey key )
        {
            if ( !(key is null) )
                _defaultEncrKey = key;

            this.Init();
        }

        public SimpleAES() { this.Init(); }
        #endregion

        #region Accessors
        /// <summary>
        /// Set: Allows assignment of a predetermined key value (32 bytes) to the encryption class;
        /// Get: Returns the currently defined AES encryption Key.
        /// </summary>
        public byte[] Key
        {
            get => _defaultEncrKey.Key;
            set
			{
                if ( !(value is null) && (value.Length > 0) )
                {
                    this._defaultEncrKey = new AESKey( value, this._defaultEncrKey.Vector );
                    this.Init(); // Update the defined Encryptor/Decryptor
                }
			}
        }

        /// <summary>
        /// Set: Allows assignment of a predetermined vector value (16 bytes) to the encryption class;
        /// Get: Returns the currently defined AES encryption vector.
        /// </summary>
        public byte[] Vector
        {
            get => _defaultEncrKey.Vector;
            set
            {
                if ( !(value is null) && (value.Length > 0) )
                {
                    this._defaultEncrKey = new AESKey( this._defaultEncrKey.Key, value );
                    this.Init(); // Update the defined Encryptor/Decryptor
                }
            }
        }
        #endregion

        #region Methods
        private void Init()
        {
            //This is our encryption method
            RijndaelManaged rm = new RijndaelManaged();

            //Create an encryptor and a decryptor using our encryption method, key, and vector.
            this._encryptorTransform = rm.CreateEncryptor( Key, Vector );
            this._decryptorTransform = rm.CreateDecryptor( Key, Vector );
        }

        /// <summary>Encrypts a set of binary data (represented as a byte array).</summary>
        /// <param name="bytes">The binary data to encrypt.</param>
        /// <returns>A binary data set containing the encrypted data.</returns>
        public byte[] Encrypt( byte[] bytes )
        {
            byte[] encrypted;
            //Used to stream the data in and out of the CryptoStream.
            using ( MemoryStream memoryStream = new MemoryStream() )
            {
                // We have to write the unencrypted bytes to the stream, then read the encrypted result back from the stream:
                CryptoStream cs = new CryptoStream( memoryStream, this._encryptorTransform, CryptoStreamMode.Write );
                cs.Write( bytes, 0, bytes.Length );
                cs.FlushFinalBlock();

                memoryStream.Position = 0;
                encrypted = new byte[ memoryStream.Length ];
                memoryStream.Read( encrypted, 0, encrypted.Length );
            }

            return encrypted;
        }

        /// The other side: Decryption

        /// <summary>Attempts to decrypt an array of bytes to an array of bytes.</summary>
        /// <param name="EncryptedValue">The raw binary data to decrypt.</param>
        /// <returns>The unencrupted binary data.</returns>
        public byte[] Decrypt( byte[] EncryptedValue )
        {
            byte[] decryptedBytes;
            using ( MemoryStream encryptedStream = new MemoryStream() )
            {
                // Write the encrypted value to the decryption stream
                try
                {
                    using ( CryptoStream decryptStream = new CryptoStream( encryptedStream, this._decryptorTransform, CryptoStreamMode.Write ) )
                    {
                        decryptStream.Write( EncryptedValue, 0, EncryptedValue.Length );
                        //decryptStream.FlushFinalBlock();
                    }
                } catch( CryptographicException e ) 
                { 
                    Console.WriteLine( e.Message ); 
                }

                // Read the decrypted value from the stream.
                encryptedStream.Position = 0;
                decryptedBytes = new Byte[ encryptedStream.Length ];
                encryptedStream.Read( decryptedBytes, 0, decryptedBytes.Length );
                encryptedStream.Close();
            }

            return decryptedBytes;
        }

		#region Static Methods
		/// -------------- Static Utility Methods (not used but may be useful) -----------
		/// <summary>Generates an encryption key.</summary>
		public static byte[] GenerateEncryptionKey()
        {
            //Generate a Key.
            RijndaelManaged rm = new RijndaelManaged();
            rm.GenerateKey();
            return rm.Key;
        }

        /// <summary>Generates a unique encryption vector</summary>
        public static byte[] GenerateEncryptionVector()
        {
            //Generate a Vector
            RijndaelManaged rm = new RijndaelManaged();
            rm.GenerateIV();
            return rm.IV;
        }

        /// <summary>Converts a string of 2-digit hexadecimal values to an equivalent array of bytes.</summary>
        /// <returns>An array of bytes populated from the supplied string.</returns>
        /// <remarks>The only valid values that can be contained in the source string are hexadecimal digits. All other characters will be removed!</remarks>
        public static byte[] HexStrToByteArray( string str )
        {
            // Convert a string to a byte array.  NOTE: Normally we'd create a Byte Array from a string using an ASCII encoding (like so).
            //      System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
            //      return encoding.GetBytes(str);
            // However, this results in character values that cannot be passed as part of a URL. So, instead, I just
            // lay out all of the byte values in a long string of 2-digit hexadecimal values.

            if ( str.Length == 0 )
                throw new Exception( "Invalid string value in StrToByteArray" );

            // Remove non-hexadecimal characters and ensure an even-length string...
            str = Regex.Replace( str, @"[^\da-fA-F]", "" );
            if ( str.Length % 2 == 1 ) str += "0";

            // Peal values out two at a time through the length of the string and add their byte-equivalent to the destination array.
            int i = 0, j = 0;
            byte[] byteArr = new byte[ (str.Length / 2) + 1 ];
            do { byteArr[ j++ ] = Convert.ToByte( str.Substring( i++, 2 ) ); } while ( ++i < str.Length );

            // return the result;
            return byteArr;
        }

        /// <summary>Convert an array of bytes into a contiguous string of 2-digit hexadecimal numbers.</summary>
        /// <returns>A string containing the values of the byte array expressed as 2-digit hexadecimal values.</returns>
        public static string ByteArrToHexString( byte[] byteArr )
        {
            // Same comment as above.  Normally the conversion would use an ASCII encoding in the other direction:
            //      System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();
            //      return enc.GetString(byteArr);

            string tempStr = "";
            for ( int i = 0; i < byteArr.Length; i++ )
                tempStr += byteArr[ i ].ToString( "X2" );

            return tempStr;
        }

        /// <summary>Encrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to encrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A binary data set (as a byte array) containing the encrypted data.</returns>
        public static byte[] Encrypt( byte[] data, byte[] key, byte[] vector ) =>
            Encrypt( data, new AESKey( key, vector ) );

        /// <summary>Encrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to encrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A binary data set (as a byte array) containing the encrypted data.</returns>
        public static byte[] Encrypt( byte[] data, AESKey key = null )
		{
            SimpleAES worker = new SimpleAES( key );
            return worker.Encrypt( data );
		}

        /// <summary>Decrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to decrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A binary data set (as a byte array) containing the decrypted data.</returns>
        public static byte[] Decrypt( byte[] data, byte[] key, byte[] vector ) =>
            Decrypt( data, new AESKey( key, vector ) );

        /// <summary>Decrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to decrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A binary data set (as a byte array) containing the decrypted data.</returns>
        public static byte[] Decrypt( byte[] data, AESKey key = null )
        {
            SimpleAES worker = new SimpleAES( key );
            return worker.Decrypt( data );
        }

        /// <summary>Encrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to encrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A string representing the encrypted data as a single hexadecimal value.</returns>
        public static string EncryptToHexString( byte[] data, byte[] key, byte[] vector ) =>
            ByteArrToHexString( Encrypt( data, key, vector ) );

        /// <summary>Encrypts a binary data set (contained in a byte array) using the supplied key and vector values.</summary>
        /// <param name="data">The data to encrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A string representing the encrypted data as a single hexadecimal value.</returns>
        public static string EncryptToHexString( byte[] data, AESKey key = null ) =>
            ByteArrToHexString( Encrypt( data, key ) );

        /// <summary>Decrypts a binary data set (contained in a hexadecimal string) using the supplied key and vector values.</summary>
        /// <param name="data">The string containing the hexadecimal value to decrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A binary data set (as a byte array) containing the decrypted value.</returns>
        public static byte[] DecryptHexString( string data, byte[] key, byte[] vector ) =>
            Decrypt( HexStrToByteArray( data ), key, vector );

        /// <summary>Decrypts a binary data set (contained in a hexadecimal string) using the supplied key and vector values.</summary>
        /// <param name="data">The string containing the hexadecimal value to decrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A binary data set (as a byte array) containing the decrypted value.</returns>
        public static byte[] DecryptHexString( string data, AESKey key = null ) =>
            Decrypt( HexStrToByteArray( data ), key );

        /// <summary>Encrypts a plaintext string using a specified key and vector.</summary>
        /// <param name="data">The string to encrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A byte array containing the binary value of the encrypted string.</returns>
        public static byte[] EncryptString( string data, byte[] key, byte[] vector ) =>
            Encrypt( Encoding.UTF8.GetBytes( data ), key, vector );

        /// <summary>Encrypts a plaintext string using a specified key and vector.</summary>
        /// <param name="data">The string to encrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A byte array containing the binary value of the encrypted string.</returns>
        public static byte[] EncryptString( string data, AESKey key = null ) =>
            Encrypt( Encoding.UTF8.GetBytes( data ), key );

        /// <summary>Decrypts a binary data set (contained in an array of bytes) using the supplied key and vector.</summary>
        /// <param name="data">The binary data to decrypt.</param>
        /// <param name="key">The key to use.</param>
        /// <param name="vector">The key vector to apply.</param>
        /// <returns>A plaintext string derived from the supplied data.</returns>
        public static string DecryptString( byte[] data, byte[] key, byte[] vector ) =>
            Encoding.ASCII.GetString( Decrypt( data, key, vector ) );

        /// <summary>Decrypts a binary data set (contained in an array of bytes) using the supplied key and vector.</summary>
        /// <param name="data">The binary data to decrypt.</param>
        /// <param name="key">An AESKey object to encrypt the data with.</param>
        /// <returns>A plaintext string derived from the supplied data.</returns>
        public static string DecryptString( byte[] data, AESKey key = null ) =>
            Encoding.ASCII.GetString( Decrypt( data, key ) );
        #endregion
        #endregion
    }
    #endregion

    public sealed class AESKey
    {
        #region Properties
        // Used to encode/decode the key into a string via 6-bit values. Stored here as hex values for compiled obfuscation.
        private static byte[] MATRIX = new byte[]
        {
            /* 
            String Equivalent: "+PpAaCcOoEeFfGgIiKkLlZzMmBbNnHhQqRrSsTtUuDdXxYy01Jj873Ww45Vv629$"
            Integers: 
              ---0----1----2----3----4----5----6----7----8----9----A----B----C----D----E----F--
                43,  80, 112,  65,  97,  67,  99,  79, 111,  69, 101,  70, 102,  71, 103,  73, 
               105,  75, 107,  76, 108,  90, 122,  77, 109,  66,  98,  78, 110,  72, 104,  81, 
               113,  82, 114,  83, 115,  84, 116,  85, 117,  68, 100,  88, 120,  89, 121,  48, 
                49,  74, 106,  56,  55,  51,  87, 119,  52,  53,  86, 118,  54,  50,  57,  36,
              ---0----1----2----3----4----5----6----7----8----9----A----B----C----D----E----F--

            Hexadecimal:
             +0    +1    +2    +3    +4    +5    +6    +7    +8    +9    +A    +B    +C    +D    +E    +F */
/* 0x00: */ 0x2b, 0x50, 0x70, 0x41, 0x61, 0x43, 0x63, 0x4f, 0x6f, 0x45, 0x65, 0x46, 0x66, 0x47, 0x67, 0x49,
/* 0x10: */ 0x69, 0x48, 0x68, 0x4c, 0x6c, 0x5a, 0x7a, 0x4d, 0x6d, 0x42, 0x62, 0x4e, 0x6e, 0x48, 0x68, 0x51,
/* 0x20: */ 0x71, 0x52, 0x72, 0x53, 0x73, 0x54, 0x74, 0x55, 0x75, 0x44, 0x64, 0x58, 0x78, 0x59, 0x79, 0x30,
/* 0x30: */ 0x31, 0x4a, 0x6a, 0x38, 0x37, 0x33, 0x57, 0x77, 0x34, 0x35, 0x56, 0x76, 0x36, 0x32, 0x39, 0x24,
        };

		public enum Depth { Unknown = 0, Bits128 = 16, Bits192 = 24, Bits256 = 32 };
        private byte[] _key;
        private byte[] _vector;
        private Depth _depth; 
        private static readonly string MATRIX_TRANSLATOR = Encoding.UTF8.GetString( MATRIX );
        #endregion

        #region Constructors
        public AESKey( Depth depth, string keySeed, string vectorSeed)
		{
            _depth = depth;
            KeyValue = keySeed;
            VectorValue = vectorSeed;
		}

        public AESKey( byte[] key, byte[] vector )
		{
            _depth = DetermineDepth( key ); 
            Key = key;
            Vector = vector;
		}
        #endregion

        #region Operators
        public static implicit operator AESKey( string source ) => AESKey.Parse( source );
        #endregion

        #region Accessors
        public byte[] Key
        {
            get => _key;
            set
            {
                if ( (value is null) || (value.Length == 0) )
                    _key = RandomSeed(_depth);
                else
                    _key = (value.Length == (int)_depth) ? value : FormatArray( value, _depth, -127 );
            }
        }

        public byte[] Vector
        {
            get => _vector;
            set
            {
                if ( (value is null) || (value.Length == 0) )
                    _vector = RandomSeed(Depth.Bits128);
                else
                    _vector = (value.Length == 16) ? value : FormatArray( value, Depth.Bits128, 0 );
            }
        }

        public Depth BitDepth => _depth;

        public string KeyValue
        {
            get => Encoding.ASCII.GetString( _key );
            set => Key = string.IsNullOrWhiteSpace( value ) ? null : Encoding.ASCII.GetBytes( value );
        }

        public string VectorValue
        {
            get => Encoding.ASCII.GetString( _vector );
            set => Vector = string.IsNullOrWhiteSpace( value ) ? null : Encoding.ASCII.GetBytes( value );
        }

        private static Random Random { get; set; } = new Random( (int)DateTime.Now.Millisecond );
        #endregion

        #region Methods
        /// <summary>Turns an array of bytes into a string of characters based on converting to 6-bit values and mapping them to the Matrix.</summary>
        private string ParseByteArray( byte[] source )
		{
            List<byte> work = new( source ), output = new();
            while ( work.Count % 6 > 0 ) work.Add( 0 ); // Pad the source to a 6-byte boundary

            for (int i = 0; i < work.Count; )
			{
                // The code below encapsulates all of the operations from the commented-out code beneath it
                // inside a single loop. This only works because the initial loop works with 8 bits per pass, 
                // while the latter only parses 6-bits per pass.
                ulong sixBytes = 0; //, test = 0;
                for (int j = 0; j < 8; j ++ )
				{
                    // "sixBytes" will be a 48-bit value populated with the appropriate 6 bytes from "work".
                    if ( j < 6 ) sixBytes += (ulong)work[ i++ ] << (j * 8);
                    // move 6 bits from "sixBytes" to the output list.
                    output.Add( (byte)((sixBytes & (0x3ful << (6 * j))) >> (6 * j)) );
                }

                // push the next 6 bytes of "work" into "sixBytes"...
                //for ( int j = 0; j < 6; j++ )
                //    sixBytes += (ulong)work[ i++ ] << (j * 8);

                // break the 48 bits from above, into 8x 6-bit values for encoding as a string...
                //for ( int j = 0; j < 8; j++ )
                //    output.Add( (byte)((sixBytes & (0x3ful << (6 * j))) >> (6 * j)) );

                //{ // Longform version of above, useful for debugging:
                //    int shift = 6 * j;
                //    ulong filter = 0x3ful << shift, value = sixBytes & filter;
                //    test += value;
                //    output.Add( (byte)(value >> shift) );
                //}
            }

            string result = ""; // Encoding.ASCII.GetString( output.ToArray() );
            foreach (byte b in output) result += MATRIX_TRANSLATOR[ b ];
            return Regex.Replace( result, $"[{MATRIX_TRANSLATOR[0]}]+$", "" ); // Remove surplus trailing zeros
        }

        /// <summary>Attempts to intuit the BitDepth of a supplied byte array when it isn't known.</summary>
        private Depth DetermineDepth( byte[] source ) =>
            (source is not null) ? source.Length switch
            {
                32 => Depth.Bits256,
                16 => Depth.Bits128,
                24 => Depth.Bits192,
                _ => Depth.Unknown
            }:
            throw new ArgumentException( $"The specified array does not correspond to a valid bit-depth. ({source.Length})" );

        private static byte[] DeconstructString( string source )
		{
            List<byte> result = new();
            if ( !string.IsNullOrWhiteSpace( source ) )
            {
                if ( source.Length % 8 > 0 ) 
                    source.PadRight( (int)Math.Ceiling( (decimal)source.Length / 8M ) * 8, '+' );

                for ( int i = 0; i < source.Length / 8; i++ )
                {
                    byte[] block = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };
                    ulong sixBytes = 0;
                    for ( int j = 0; j < 8; j++ )
                    {
                        ulong value = (ulong)MATRIX_TRANSLATOR.IndexOf( source[ (i * 8) + j ] );
                        sixBytes += value << (6 * j);
                    }

                    block.Fill<byte>( 0, 8, false );
                    for ( int j = 0; j < 6; j++ )
                        result.Add( (byte)((sixBytes & (0xffUL << (j * 8))) >> (j * 8)) );
                }
            }

            while ( result.Count % 8 > 0 ) result.Add( 0 );

            return result.ToArray();
		}

        public static AESKey Parse( string value )
		{
            Regex regex = new( $"^[«{{]?(?<key>[{MATRIX_TRANSLATOR}]+)[^{MATRIX_TRANSLATOR}]+(?<vector>[{MATRIX_TRANSLATOR}]+)[}}»]?$" );
            if ( (value is not null) && regex.IsMatch( value ) )
            {
                Match m = regex.Match( value );
                if ( m.Groups[ "key" ].Success && m.Groups[ "vector" ].Success )
                    return new AESKey( DeconstructString( m.Groups[ "key" ].Value ), DeconstructString( m.Groups[ "vector" ].Value ) );
			}

            throw new ArgumentException( $"The supplied string isn't recognized: \"{value}\"" );
        }

        public static AESKey Parse( byte[] binValue )
        {
            string text = "";
            if ( (binValue is not null) && (binValue.Length > 24) )
            {
                foreach ( byte b in binValue )
                    text += (char)b;

                return Parse( text );
            }
            throw new ArgumentException( $"The supplied binary array wasn't recognized: \"{text}\"" );
        }

        public override string ToString() => ToString( "§" );

        public string ToString( string spacer )
        {
            if ( string.IsNullOrEmpty( spacer ) || Regex.IsMatch( spacer, $"[{MATRIX_TRANSLATOR}]" ) ) spacer = "§";
            return $"{{{ParseByteArray( Key )}{spacer}{ParseByteArray( Vector )}}}";
        }

        /// <summary>Returns the Text version of the Cipher as generated by "ToString()" as a byte array.</summary>
        public byte[] ToArray( string spacer = "§" )
		{
            string text = this.ToString( spacer );
            List<byte> bytes = new();
            foreach ( char c in text )
                bytes.Add( (byte)c );
            return bytes.ToArray();
		}

        /// <summary>Takes a provided array of bytes and truncates it to a specified length.</summary>
        /// <param name="source">The byte[] array to process.</param>
        /// <param name="size">The length that the resulting array is to be constrained to.</param>
        /// <param name="pad">Indicates what to do if the provided "source" array is shorter than the specified "size"</param>param>
        /// <remarks>
        /// Pad:
        /// If set to -1, values will be padded with randomized bytes. NOTE: This setting really only works for 1-way encryption!
        /// If set to -2, a short "source" value will generate an Exception.
        /// Any positive value will have its low-order byte value assigned to all remaining elements.
        /// The default setting pads the array with 0's.
        /// </remarks>
        private static byte[] TruncateArray( byte[] source, int size, sbyte pad = 0 )
        {
            if ( source is null )
                throw new NullReferenceException( "The provided source array is null!" );

            if ( (source.Length < size) && (pad == -2) )
                throw new InvalidDataException( $"There are not enough elements in the array ({source.Length}) to satisfy the requested size ({size})." );

            List<byte> work = new( source );

            while ( work.Count < size ) work.AddRange( pad < 0 ? RandomSeed( Depth.Bits256 ) : new byte[32].Fill((byte)pad) );
            while ( work.Count > size ) work.RemoveAt( work.Count - 1 );

            return work.ToArray();
        }

        /// <summary>Produces a byte array of a specified bit-depth using the provided source as a seed.</summary>
        /// <param name="source">A byte array to base the result on.</param>
        /// <param name="bitDepth">How many bits are to be present in the result.</param>
        /// <param name="pad">If the bit depth is longer than the seed, this defines how to pad the result.</param>
        /// <returns>A byte array containing the specified number of bits.</returns>
        /// <remarks>
        /// If "Pad" is set to a value less than 0, the result will be padded with randomized bytes. NOTE: This setting really only works for 1-way encryption!
        /// Any positive value will have its low-order byte value assigned to all remaining elements.
        /// The default setting pads the array with 0's.
        /// </remarks>
        public static byte[] FormatArray( byte[] source, Depth bitDepth, sbyte pad = 0 )
		{
            int sourceBitLength = (source is null ? 0 : source.Length );
            if ( sourceBitLength == 0 )
                throw new ArgumentException( "The provided source array cannot be empty or null!" );

            if ( sourceBitLength > (int)bitDepth ) return new List<byte>( source ).ToArray( (int)bitDepth );

            Stack<byte> rnd = new( RandomSeed( Depth.Bits256 ) ); // Create a list of 32 random byte values
            List<byte> worker = new( source );
            for ( int i = worker.Count; i < (int)bitDepth; i++ )
                worker.Add( (pad < 0) ? rnd.Pop() : (byte)(pad & 0x7f) );
            return worker.ToArray();
        }

        /// <summary>Produces an array of randomly selected bytes with a length corresponding to the specified bit depth.</summary>
        private static byte[] RandomSeed( Depth depth = Depth.Bits128 )
		{
            byte[] seed = new byte[ (int)depth ];
            for ( int i = 0; i < ((int)depth / 4); i++ )
            {
                uint value = (uint)Random.Next(); // <-- 4-byte value!
                for (int j = 0; j < 4; j++ )
                    seed[ (i * 4) + j ] = (byte)((value & (0xffu << (j*8))) >> (j * 8));
            }

            return seed;
		}

        /// <summary>Generates an encryption key array from a specified string.</summary>
        /// <param name="seed">A string containing the data to convert into a key value.</param>
        /// <param name="pad">
        /// Indicates what to do if the provided "source" array is shorter than the specified "size":
        /// If set to -1, values will be padded with randomized bytes. NOTE: This setting really only works for 1-way encryption!
        /// If set to -2, a short "source" value will generate an Exception.
        /// Any positive value will have its low-order byte value assigned to all remaining elements.
        /// The default setting pads the array with 0's.
        /// </param>
        /// <param name="depth">Defines the length of the result (in bits) the default (128 bits) is the standard AES bit depth.</param>
        /// <returns>A 32-byte array culled from the supplied string and padded according to the specification.</returns>
        public static byte[] GenerateEncryptionKey( string seed = "", sbyte pad = 0, Depth depth = Depth.Bits128 ) =>
            FormatArray( string.IsNullOrEmpty( seed ) ? RandomSeed(depth) : Encoding.ASCII.GetBytes( seed ), depth, pad );

        /// <summary>Generates an encryption vector array from a specified string.</summary>
        /// <param name="seed">A string containing the data to convert into a vector value.</param>
        /// <param name="pad">
        /// Indicates what to do if the provided "source" array is shorter than the specified "size":
        /// If set to -1, values will be padded with randomized bytes. NOTE: This setting really only works for 1-way encryption!
        /// If set to -2, a short "source" value will generate an Exception.
        /// Any positive value will have its low-order byte value assigned to all remaining elements.
        /// The default setting pads the array with 0's.
        /// </param>
        /// <returns>A 16-byte array culled from the supplied string and padded according to the specification.</returns>
        public static byte[] GenerateEncryptionVector( string seed = "", sbyte pad = 0 ) =>
            FormatArray( string.IsNullOrEmpty( seed ) ? RandomSeed() : Encoding.ASCII.GetBytes( seed ), Depth.Bits128, pad );
		#endregion
	}
}